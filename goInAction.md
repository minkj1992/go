# Ch 01 About Go

## advantage
- 빠른 컴파일 타임
- 내장 동시성 라이브러리( 별도의 스레드 lib 없어도 됨)
- 효과적인 타입 시스템(oop 오버헤드 줄임)
- GC

## 개발 속도

- 기존의 정적 언어가 컴파일시, 전체 라이브러리의 의존성을 탐색하는 것과 달리, Go 컴파일러는 **직접 참조하는 라이브러리의 의존성만을 해석함**
- 동적 언어들과 비교해서, type safety를 지원(컴파일 에러)

## 동시성

- `goroutine`
  - 스레드와 유사하지만 더 적은 메모리 소비, 더 적은 양의 코드로 구현 가능
- `channel`
  - 동기화 기능 내장
  - `typed message`를 활용해 고루틴간의 데이터 공유할 수 있게 하는 **데이터 구조**

## 고루틴

Go에서는 여러 개의 고루틴이 하나의 스레드에서 동작합니다. c, java로 웹 서버를 개발하면 여러 request를 동시에 처리하기 위해 스레드를 사용하여야 하지만 (이 때문에 더욱 많은 코드가 추가 되어야 한다.), 반면 GO는 고루틴을 이용해 동시성을 자체적으로 지원하는 `net/http` 라이브러리를 사용합니다. 즉 자동으로 서버로 유입된(inbound) request들은 자동으로 고루틴에서 동작하게 됩니다.

고루틴들은 Go 런타임이 설정한 논리 프로세서 갯수에 따라 자동으로 고루틴 스케줄링을 처리하며, 각각의 논리 프로세서는 하나의 os 스레드에 연결됩니다. (os 스레드는 parallel일 수도, concurrent하게 동작할 수도..? 내가 알기로 window는 thread로 parallel을 관리한다고 들었는데, 이 경우 parallel 가능할 듯)

Q) 고루틴들은 하나의 thread에서 context switching이 일어나는가?
Q) os thread는 PCB가 존재하는가?

## Channel
채널은 race condition으로 부터 공유 자원을 보호하기 위한 패턴을 제공합니다. **채널을 통해 어느 한 시점에 하나의 고루틴만이 데이터를 수정할 수 있는 패턴 적용**

`고루틴 -채널-> 고루틴 -채널-> 고루틴`

다음과 같은 flow에 따라서 채널을 통해 데이터 교환이 이뤄지게 함으로 **수정에 대한 순서를 적용가능합니다.**

- 주의 사항
  - 채널이 고루틴 간의 데이터 접근을 보호하지 않고, 데이터 교환에 대한 동기화만 제공함.
  - 즉 채널을 통해 값을 전달한다면, 고루틴들은 안전하게 자신이 필요한 값들을 사용할 수 있지만, 포인터를 교환 후 읽기/쓰기 모두 수행한다면 **여전히 데이터 동기화가 필요**

## 타입 시스템
전통적인 상속 기반의 모델을 사용하는 타 언어들과 비교해 Go는 `composition`이라는 디자인 패턴을 활용한 타입 임베드를 제공합니다.

추가로 go 에서는 어떤 타입이 어떤 인터페이스를 구현하고 있다는 것을 선언할 필요가 없이, 동작(행위)자체를 모델링 하는 인터페이스가 존재하여 컴파일러는 현재 사용하고 있는 타입의 값이 사용하고자 하는 인터페이스를 만족하는지를 검사하기만 하면 된다.

## 인터페이스
자바와 달리 Go에서 인터페이스는 주로 하나의 동작만을 표현한다.

- `io.Reader`: 우리가 정의하는 타입이 표준 라이브러리의 다른 함수들이 이미 알고 있는 방법으로 데이터를 읽을 수 있다는 것을 간단히 표현 간단히 표현가능

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```


---

# CH02 Go Basic
- 프로그램 아키텍처
- 타입, 변수, 함수, 메서드 선언
- 고루틴 실행 및 동기화
- 인터페이스를 이용한 범용 코드 작성
- 오류 구현


## 포괄적인 go 철학 & 구조
- 최소화된 키워드 집합, 내장 함수, 간결한 문법
- 광범위한 표준 라이브러리 지원

---

# CH03 패키징과 내장 도구들

## TL;DR

- 패키지는 Go에서 코드를 체계화하는 가장 기본적인 단위
- `GOPATH` 환경 변수에 지정된 경로는 Go 소스 코드가 디스크상에 저장되고, 컴파일 되고 설치되는 경로를 결정하는데 사용
- 3rd lib 의존성들은 `$go get`명령을 이용해 `GOPATH` 환경 변수에 지정된 경로에 다운로드 및 설치 가능


## Package
> 모든 go 프로그램은 패키지라고 불리는 일련의 파일 그룹을 통해 관리된다.

#### 패키지 기초
- 모든 .go 파일들은 반드시 공백 및 주석을 제외한 첫 번째 줄에 자신이 속한 패키지의 이름을 선언한다.
- 패키지는 하나의 디렉터리에 저장된다.
- 같은 패키지 이름을 선언하는 모든 .go 파일은 하나의 디렉터리에 저장되어야 한다.

#### 패키지의 이름 규칙
- 패키지의 이름 규칙은 패키지가 저장되는 **디렉터리의 이름을 따르는 것**
- 이렇게 할 경우 패키지를 가져올 때 패키지의 이름을 쉽게 알 수 있다는 장점이 있다.

#### main 패키지
- go cmd를 위한 것으로, **실행 가능한 바이너리 파일로 컴파일 되기 위한 패키지를 정의(바이너리의 1st 진입점)**
- go로 구현한 모든 실행 가능한 프로그램들은 반드시 main 이라는 이름의 패키지를 가지고 있어야 한다.
- main 패키지는 반드시 `main()`함수를 선언해야 한다.

#### import
- import 구문은 컴파일러에게 패키지를 탐색할 디스크상의 경로를 알려준다.